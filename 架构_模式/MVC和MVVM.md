参考：

1. [iOS 关于MVC和MVVM设计模式的那些事](https://www.jianshu.com/p/caaa173071f3)

### MVC的弊端
MVC的利弊大家想必是有目共睹的，Massive View Controller的说法也并非空穴来风的。让我们一起探讨MVC的弊端，剖析问题产生原因，打造一个轻量级的ViewController，明确MVC设计模式中各个角色的职责。


#### 1.厚重的View Controller
**M**：模型model的对象通常非常的简单。根据Apple的文档，model应包括数据和操作数据的业务逻辑。而在实践中，model层往往非常薄，不管怎样，model层的业务逻辑不应被拖入到controller。

**V**：视图view通常是UIKit控件（component，这里根据习惯译为控件）或者编码定义的UIKit控件的集合。View的如何构建（PS：IB或者手写界面）何必让Controller知晓，同时View不应该直接引用model（PS：现实中，你懂的！），并且仅仅通过IBAction事件引用controller。业务逻辑很明显不归入view，视图本身没有任何业务。

**C**：控制器controller。Controller是app的“胶水代码”：协调模型和视图之间的所有交互。控制器负责管理他们所拥有的视图的视图层次结构，还要响应视图的loading、appearing、disappearing等等，同时往往也会充满我们不愿暴露的model的模型逻辑以及不愿暴露给视图的业务逻辑。
网络数据的请求及后续处理，本地数据库操作，以及一些带有工具性质辅助方法都加大了Massive View Controller的产生。

#### 2.遗失（无处安放）的网络逻辑
苹果使用的MVC的定义是这么说的：所有的对象都可以被归类为一个model，一个view，或是一个controller。
你可能试着把它放在Model对象里，但是也会很棘手，因为网络调用应该使用异步，这样如果一个网络请求比持有它的model生命周期更长，事情将变的复杂。显然View里面做网络请求那就更格格不入了，因此只剩下Controller了。若这样，这又加剧了Massive View Controller的问题。若不这样，何处才是网络逻辑的家呢？

#### 3.较差的可测试性
由于`View Controller`混合了视图处理逻辑和业务逻辑，分离这些成分的单元测试成了一个艰巨的任务。若一个`Massive View Controller`有上万行代码，要你编写个单元测试，我敢保证，你不是想写，你是想死，分分钟填表走人。





### MVVM 的优势

1. 低耦合：View 可以独立于Model变化和修改，一个 viewModel 可以绑定到不同的 View 上
2. 可重用性：可以把一些视图逻辑放在一个 viewModel里面，让很多 view 重用这段视图逻辑
3. 独立开发：开发人员可以专注于业务逻辑和数据的开发 viewModel，设计人员可以专注于页面设计
4. 可测试：通常界面是比较难于测试的，而 MVVM 模式可以针对 viewModel来进行测试



### MVVM 的弊端

1.** 数据绑定使得Bug 很难被调试。**你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。
2. **对于过大的项目，数据绑定和数据转化需要花费更多的内存（成本）**。主要成本在于：

    1. 数组内容的转化成本较高：数组里面每项都要转化成Item对象，如果Item对象中还有类似数组，就很头疼。
    2. 转化之后的数据在大部分情况是不能直接被展示的，为了能够被展示，还需要第二次转化。
    3. 只有在API返回的数据高度标准化时，这些对象原型（Item）的可复用程度才高，否则容易出现类型爆炸，提高维护成本。
    4. 调试时通过对象原型查看数据内容不如直接通过NSDictionary/NSArray直观。
    5. 同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。