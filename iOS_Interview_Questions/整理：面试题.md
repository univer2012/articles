## iOS 面试题（一）寻找最近公共 View

> 题目：找出两个 UIView 的最近的公共 View，如果不存在，则输出 nil 。
>
> 分析：这其实是数据结构里面的找最近公共祖先的问题。



1、通过 view 的 superview 属性，一直找到根节点，并把这个过程得到的view用数组存起来，我们称之为路径数组。

2、对于两个 view A 和 view B，我们可以得到两个路径。

3、从0开始循环2个路径数组，当2个路径数组中有元素相同时，则这个相同的元素就是最近公共view。





对3的改进1：将一个路径数组中的所有点先放进 NSSet 中，使用`[set containsObject:targetView]`来查找最近公共view。



对3的改进2：可以使用类似归并排序的思想，用两个「指针」，分别指向两个路径的根节点，然后从根节点开始，找第一个不同的节点，第一个不同节点的上一个公共节点，就是我们的答案。



swift：还可以使用 UIView 的 `isDescendant` 方法来简化我们的代码，不过这样写的话，时间复杂度应该也是 O(N^2) 的。



swift改进2：利用 Optinal 的 flatMap 方法。

---

## iOS 面试题（二）什么时候在 block 中不需要使用 weakSelf

> 问题:我们知道，在使用 block 的时候，为了避免产生循环引用，通常需要使用 weakSelf 与 strongSelf，写下面这样的代码：
```objc
__weak typeof(self) weakSelf = self;
[self doSomeBlockJob:^{
    __strong typeof(weakSelf) strongSelf = weakSelf;
    if (strongSelf) {
        ...
    }
}];
```
> 那么请问：什么时候在 block里面用self，不需要使用weakself?

**当block本身不被self 持有，而被别的对象持有，同时不产生循环引用的时候，就不需要使用weakself了**。最常见的代码就是UIView的动画代码，我们在使用`UIView animateWithDuration:animations:`方法 做动画的时候，并不需要使用weakself，因为引用持有关系是：

> **UIView 的某个负责动画的对象持有block，block 持有了self。因为 self 并不持有 block，所以就没有循环引用产生，所以不需要使用 weak self 了。**



> 当动画结束时，UIView会结束持有这个 block，如果没有别的对象持有block的话，block 对象就会释放掉，从而 block会释放掉对于 self 的持有。整个内存引用关系被解除。

---



## iOS 面试题（三）什么时候在 block 中不需要使用 weakSelf

我们知道，在使用 block 的时候，为了避免产生循环引用，通常需要使用 weakSelf 与 strongSelf，写下面这样的代码：

```
__weak typeof(self) weakSelf = self;
[self doSomeBackgroundJob:^{
    __strong typeof(weakSelf) strongSelf = weakSelf;
    if (strongSelf) {
        ...
    }
}];
```

 那么请问：为什么 block 里面还需要写一个 strong self，如果不写会怎么样？

在 block 中先写一个 strong self，**其实是为了避免在 block 的执行过程中，突然出现 self 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退。**

---



## iOS 面试题（五）：weak 的内部实现原理

 问题：weak 变量在引用计数为0时，会被自动设置成 nil，这个特性是如何实现的？
答案：在 [Friday QA](https://mikeash.com/pyblog/friday-qa-2010-07-16-zeroing-weak-references-in-objective-c.html) 上，有一期专门介绍 weak的实现原理。



《Objective-C高级编程》一书中也介绍了相关的内容。

简单来说，**系统有一个全局的 CFMutableDictionary 实例，来保存每个对象的 weak 指针列表，因为每个对象可能有多个 weak 指针，所以这个实例的值是 CFMutableSet 类型。**

剩下我们要做的，就是**在引用计数变成 0 的时候，去这个全局的字典里面，找到所有的 weak 指针，将其值设置成 nil**。如何做到这一点呢？[Friday QA](https://mikeash.com/pyblog/friday-qa-2010-07-16-zeroing-weak-references-in-objective-c.html) 上介绍了一种类似 <u>KVO 实现的方式</u>。**当对象存在 weak 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 release 方法。在 release 方法中，去从全局的 CFMutableDictionary 字典中找到所有的 weak 对象，并且设置成 nil。**我摘抄了 Friday QA 上的实现的核心代码，如下：

```objc
    Class subclass = objc_allocateClassPair(class, newNameC, 0);
    Method release = class_getInstanceMethod(class, @selector(release));
    Method dealloc = class_getInstanceMethod(class, @selector(dealloc));
    class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release));
    class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc));
    objc_registerClassPair(subclass);
```



---



## iOS 面试题（六）：自己写的 view 成员，应该用 weak 还是 strong？

问题：我们知道，从 Storyboard 往编译器拖出来的 UI 控件的属性是 weak 的，如下所示

```
@property (weak, nonatomic) IBOutlet UIButton *myButton;
```

 那么，如果有一些 UI 控件我们要用代码的方式来创建，那么它应该用 weak 还是 strong 呢？为什么？

答：

Storyboard 拖出来的控件即使是 strong 的，也不会有循环引用问题。

Storyboard 拖出来的**UI 控件默认用 weak，根源还是苹果希望只有这些 UI 控件的父 View 来强引用它们。而 ViewController 只需要强引用 ViewController.view 成员，就可以间接持有所有的 UI 控件**。<font color=#FF0000>这样有一个好处是：在以前，当系统收到 Memory Warning 时，会触发 ViewController 的`viewDidUnload` 方法。这样的弱引用方式，可以让整个 view 整体都得到释放，也更方便重建时整体重新构造。</font>

但是首先 viewDidUnload 方法在 iOS 6 开始就被废弃掉了，苹果用了更简单有效地方式来解决内存警告时的视图资源释放，具体如何做的呢？嗯，这个可以当作某一期的面试题展开介绍。总之就是，**除非你特殊地操作 view 成员，否则ViewController.view 的生命期和 ViewController 是一样的。**

**在这种情况下， UI 控件是不是 weak 其实关系并不大。当 UI 控件是 weak 时，它的引用计数是 1，持有它的是它的 superview。当 UI 控件是 strong 时，它的引用计数是 2，持有它的有两个地方，一个是它的 superview，另一个是这个 strong 指针。所以，不管是手写代码还是 Storyboard，UI 控件是 strong 都不会有循环引用。**

那么回到我们的最初的问题，<font color=#FF0000>自己写的 view 成员，应该用 weak 还是 strong？</font>**我个人觉得应该用 strong，因为用 weak 并没有什么特别的优势**，加上上一篇面试题文章中，我们还看到，**其实 weak 变量会有额外的系统维护开销的。如果你没有使用它的特别理由，那么用 strong 的话应该更好。**

<font color=#038103>当然，如果你非要用 weak，其实也没什么问题。只需要注意在赋值前，先把这个对象用 addSubView 加到父 view 上，否则可能刚刚创建完，它就被释放了。</font>

另外有读者也提到，如果你要做 Lazy 加载，那么你也只能选择用 strong。

>  1.**懒加载的对象必须用strong的原因：如果使用weak，对象并没有被强引用，过了懒加载，对象就会被释放掉。**



---



### 2. 什么情况使用 weak 关键字，相比 assign 有什么不同？

什么情况使用 weak 关键字？


1. 在 ARC 中，在有可能出现循环引用的地方，往往要通过让其中一端使用 weak 来解决，比如: delegate 代理属性。

2. 自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用 weak。自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：***《IBOutlet连出来的视图属性为什么可以被设置成weak?》***

#### 不同点：

 1. ==`weak` 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似。在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。==

    ==而 `assign` 的“设置方法”只用于基本数据类型的简单赋值操作。==

 2. ==assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。==



---



### 3. 怎么用 copy 关键字？

用途：

  1. NSString、NSArray、NSDictionary 等等经常使用copy关键字。是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
  2. block 也经常使用 copy 关键字。具体原因见[官方文档：***Objects Use Properties to Keep Track of Blocks***](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12)：



block 使用 copy 是从 MRC 遗留下来的“传统”：

**在 MRC 中，方法内部的 block 是在栈区的，使用 copy 可以把它放到堆区。**

**在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。**

<font color=#038103>如果不写 copy ，该类的调用者有可能会忘记或者根本不知道”编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前手动拷贝属性值。这种操作多余而低效。</font>你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？

 ```Objective-C
 @property (nonatomic, copy) NSString *userId;

 - (instancetype)initWithUserId:(NSString *)userId {
    self = [super init];
    if (!self) {
        return nil;
    }
    _userId = [userId copy];
    return self;
 }

 ```

 ![enter image description here](http://cc.cocimg.com/api/uploads/20150803/1438583398598540.png)

下面做下解释：
 ==copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。==

==**当属性类型为 NSString 时，经常用此特质来保护其封装性**，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例==。

**这个类是 NSString 的子类，表示一种可修改其值的字符串。此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改**。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。



---



#### 问：用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？

答：

用NSMutableString的mStr，赋值NSString A和NSMutableString B，分别用assign、strong、retain、copy去修饰NSString A和NSMutableString B的结论如下：

1. `assign`：不是浅拷贝也不是深拷贝。只是简单地把指针指向mStr的内存地址。

     所以引用计数一直是1，且随着mStr的改变而改变。

2. `strong`：都是浅拷贝，引用计数加1，都会随着mStr的改变而改变。
3. `retain`：都是浅拷贝，引用计数加1，都会随着mStr的改变而改变。
4. `copy`：都是深拷贝，引用计数等于1，不会随着mStr的改变而改变。

为了保护NSString、NSArray、NSDictionary的封装性，同时为了这些数据的安全，需要使用`copy`来修饰，对数据进行深拷贝，防止这些值在不知情的情况下遭人更改。



---



### 4. 这个写法会出什么问题： `@property (copy) NSMutableArray *array;`

两个问题：

1. 添加、删除、修改数组内的元素的时候，程序会因为找不到对应的方法而崩溃。因为 copy 就是复制一个不可变 NSArray 的对象；
2. 使用了 atomic 属性会严重影响性能 ；

运行如下代码：

```objc
@interface SGHInverviewQuestionsViewController ()

@property (copy) NSMutableArray *array;

@end

@implementation SGHInverviewQuestionsViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1,@2,nil];
    self.array = arr;
    [self.array removeObjectAtIndex:0];
}
```

会发现，`self.array`的类型由`NSMutableArray`变成了`NSArray`，如图：

![WX20200430-181605.png](https://upload-images.jianshu.io/upload_images/843214-914c3019ab77309c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这是因为用copy修饰后，会把局部变量arr先拷贝，再赋值给`self.array`，所以是`NSArray`类型的了。



第2条原因，如下：

> 该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。



在iOS开发中，你会发现，几乎所有属性都声明为 `nonatomic`。

**一般情况下，并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)。若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。**例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。

因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。



---



